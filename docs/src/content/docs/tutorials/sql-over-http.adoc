---
title: SQL over HTTP
---

Assuming you have successfully started an XTDB server, this tutorial walks through basic HTTP API usage and showcases a few of the novel features of XTDB. The examples should be easily translatable to any language (or you could use one of the many supported link:/drivers[client drivers]), and cURL commands are also provided for convenience.

== Status

To confirm XTDB is running:

`GET` to `localhost:3000/status`

If that returns, everything should be up and running.

== Transact

To run your first transaction, send the following:

`POST` to `localhost:3000/tx`

[source,json]
----
{
  "txOps": [{"sql": "INSERT INTO people (xt$id, name) VALUES (6, 'fred')"}]
}
----

.cURL command
[%collapsible%closed]
====
[source,bash]
----
# note that dollar symbols in the SQL string must be escaped
sql="INSERT INTO people (xt\$id, name) VALUES (6, 'fred')"; \    
curl --json "{\"txOps\": [{\"sql\": \"${sql}\"}]}" localhost:3000/tx
----
====

Note that the `people` table doesn't have to be defined beforehand - the table is created dynamically during the INSERT along with any supplied columns and types.

Each record in XTDB must contain a user-provided `xt$id` primary key column, but other columns are fully dynamic. Note that `xt$` is a reserved prefix convention for namepacing system-mandated columns and other XTDB-specific database objects.

Transactions are durable and processed asynchronously, i.e. if you wait a few milliseconds for the processing to finish, you can then query that data in a subsequent request

== Query

`POST` to `localhost:3000/query`

[source,json]
----
{
  "query": {"sql": "SELECT * FROM people"}}
}
----

.cURL command
[%collapsible%closed]
====
[source,bash]
----
sql="SELECT * FROM people"; \    
curl --json "{\"query\": {\"sql\": \"${sql}\"}}" localhost:3000/query
----
====

You can also ensure that the query reflects our transaction (after it has been either committed or aborted) by supplying the 'TransactionKey' map returned from our transation as the value for `afterTx` within `queryOpts`. Note that the example map under the 'afterTx' key is shown here for illustration purposes only and you must replace it with exact the map returned from the Transact step:

`POST` to `localhost:3000/query`

[source,json]
----
{
  "query": {"sql": "SELECT * FROM people"},
  "queryOpts": {"afterTx": {"txId": 0,
                            "systemTime":"2024-03-04T14:31:03.728415Z"}}
}
----

.cURL command
[%collapsible%closed]
====
[source,bash]
----
sql="SELECT * FROM people"; \    
curl --json "{\"query\": {\"sql\": \"${sql}\"},\
              \"queryOpts\": {\"afterTx\": {\"txId\": 0,\
                                            \"systemTime\": \"2024-03-04T14:31:03.728415Z\"}}}" localhost:3000/query
----
====

== Working with documents

XTDB is designed to work with JSON-like nested data as a first-class concept. Which means you can send complex INSERTs like the following transaction:

`POST` to `localhost:3000/tx`

[source,json]
----
{
  "txOps": [{"sql": "INSERT INTO people (xt$id, name, info)
                     VALUES (6, 'fred', {'height': 172,
                                         'age': 29,
                                         'likes': ['apples'])"}]
}
----

.cURL command
[%collapsible%closed]
====
[source,bash]
----
# note that dollar symbols in the SQL string must be escaped
sql="\
INSERT INTO people (xt\$id, name, info) \
VALUES (6, 'fred', {'height': 172, \
                    'age': 29, \
                    'likes': ['apples']})"; \    
curl --json "{\"txOps\": [{\"sql\": \"${sql}\"}]}" localhost:3000/tx
----
====

== Basis allows you to re-run queries

Despite having just 'replaced' the version of the document in the previous tep, you can still re-run the previous query exactly and see that the results against the earlier basis remain the same. This is accomplished by defining a `basis` map which contains the same TransactionKey as used previously (within `afterTx`) but this time under the `atTx` key (once again, the TransactionKey shown is purely illustrative):

`POST` to `localhost:3000/query`

[source,json]
----
{
  "query": {"sql": "SELECT * FROM people"},
  "queryOpts": {"basis": {"atTx": {"txId": 0,
                                   "systemTime":"2024-03-04T14:31:03.728415Z"}}}
}
----

.cURL command
[%collapsible%closed]
====
[source,bash]
----
sql="SELECT * FROM people"; \    
curl --json "{\"query\": {\"sql\": \"${sql}\"},\
              \"queryOpts\": {\"basis\": {\"atTx\": {\"txId\": 0,\
                                                     \"systemTime\": \"2024-03-04T14:31:03.728415Z\"}}}}" localhost:3000/query
----
====

A basis map is like a pointer to a snapshot of a previous version of the entire database state, except unlike snapshots in other systems there is no copying or explicit snapshot creation required.

If you re-run the previous query with the previous basis (returned by the first transaction), you _won't_ see the new version of Fred's record.

A basis is stable and allows you to re-run unmodified queries indefinitely. This is useful for debugging, auditing, and exposing application data for processing in downstream systems (generating reports, analytics etc.)

== System-Time Columns

The mechanism underpinning the basis concept is called 'System Time'.

Normally a SQL database will irreversibly lose access to prior states of data after transactions containing `UPDATE` or `DELETE` statements are committed. System-time versioning is a standard defined in link:https://en.wikipedia.org/wiki/SQL:2011[SQL:2011], but unlike other implementations, XTDB has it baked into the core of the database engine such that all data is versioned by default and all modification operations are non-destructive.

This minimises the circumstances where developers need to reach for backups or ETL integrations with other warehousing systems in order to recover data. It also provides an opportunity to avoid complicating application schemas with "soft delete" columns and audit tables.

The system-time columns `xt$system_from` and `xt$system_to` are hidden from view by default but, when specified, can be found on every table within regular SQL - and can also be combined with the previously described capability to query at a prior basis (if desirable):

`POST` to `localhost:3000/query`

[source,json]
----
{
  "query": {"sql": "SELECT people.*, people.xt$system_from, people.xt$system_to, FROM people"},
  "queryOpts": {"basis": {"atTx": {"txId": 0,
                                   "systemTime":"2024-03-04T14:31:03.728415Z"}}}
}
----

.cURL command
[%collapsible%closed]
====
[source,bash]
----
sql="SELECT people.*, people.xt$system_from, people.xt$system_to FROM people"; \    
curl --json "{\"query\": {\"sql\": \"${sql}\"},\
              \"queryOpts\": {\"basis\": {\"atTx\": {\"txId\": 0,\
                                                     \"systemTime\": \"2024-03-04T14:31:03.728415Z\"}}}}" localhost:3000/query
----
====

The full system-time history for a set of records in a table can be retrieved by specifying `FOR ALL SYSTEM_TIME` after each table reference:

`POST` to `localhost:3000/query`

[source,json]
----
{
  "query": {"sql": "SELECT people.*, people.xt$system_from, people.xt$system_to, FROM people FOR ALL SYSTEM_TIME"},
  "queryOpts": {"basis": {"atTx": {"txId": 0,
                                   "systemTime":"2024-03-04T14:31:03.728415Z"}}}
}
----

.cURL command
[%collapsible%closed]
====
[source,bash]
----
sql="SELECT people.*, people.xt\$system_from, people.xt\$system_to FROM people FOR ALL SYSTEM_TIME"; \    
curl --json "{\"query\": {\"sql\": \"${sql}\"},\
              \"queryOpts\": {\"basis\": {\"atTx\": {\"txId\": 0,\
                                                     \"systemTime\": \"2024-03-04T14:31:03.728415Z\"}}}}" localhost:3000/query
----
====

You can also run queries against individual tables at specific timestamps using `FOR SYSTEM_TIME AS_OF <timestamp>` and use temporal period operators (`OVERLAPS`, `PRECEDES` etc.) to interrogate audit trails - see the link:/reference/main/sql/queries[SQL documentation].

== ERASE as hard-delete

Where data does need to be erased ("hard deleted"), an `ERASE` operation is provided:

`POST` to `localhost:3000/tx`

[source,json]
----
{
  "txOps": [{"sql": "ERASE FROM people WHERE people.name = 'fred')"}]
}
----

.cURL command
[%collapsible%closed]
====
[source,bash]
----
sql="ERASE FROM people WHERE people.name = 'fred'"; \    
curl --json "{\"txOps\": [{\"sql\": \"${sql}\"}]}" localhost:3000/tx
----
====

The ERASE is effective as soon as the transaction is committed, and can be verified by again setting the `afterTx` to the previous transaction. Once again the TransactionKey shown is illustrative and you must replace it with the one returned by your XTDB server:

`POST` to `localhost:3000/query`

[source,json]
----
{
  "query": {"sql": "SELECT * FROM people"},
  "queryOpts": {"afterTx": {"txId": 2,
                            "systemTime":"2024-03-04T14:32:03.728415Z"}}
}
----

.cURL command
[%collapsible%closed]
====
[source,bash]
----
sql="SELECT * FROM people"; \    
curl --json "{\"query\": {\"sql\": \"${sql}\"},\
              \"queryOpts\": {\"afterTx\": {\"txId\": 2,\
                                            \"systemTime\": \"2024-03-04T14:32:03.728415Z\"}}}" localhost:3000/query
----
====

Under the hood, the relevant data is guaranteed to be fully erased only once all background index processing has completed and the changes have been uploaded to object storage.

== Valid-Time for advanced time-travel

Everything demonstrated so far only scratches the surface of what XTDB can do, given that XTDB is a full SQL implementation with all the implications that has, however there is one further aspect where XTDB is very different to most databases: ubiquitous 'Valid-Time' versioning.

In addition to system-time versioning, SQL:2011 also defines 'application-time' versioning. XTDB applies this versioning to all tables. It allows for several advanced usage scenarios:

. *foo* - a
. *bar* - b

