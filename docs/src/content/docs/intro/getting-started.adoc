---
title: Getting started
---
:icon: /images/icons
:clojure: /drivers/clojure/getting-started.html
:java: /drivers/java/getting-started.html
:kotlin: /drivers/kotlin/getting-started.html

XTDB can run in-process (in a JVM), or through traditional client-server connections.

== Client/Server

You can start an XTDB server using the 'standalone' Docker image:

[source,shell]
----
docker pull ghcr.io/xtdb/xtdb-standalone-ea

docker run -tip 3000:3000 ghcr.io/xtdb/xtdb-standalone-ea
----

This starts a server on http://localhost:3000.
By default, your data will be saved in a local directory in the Docker image, but you can also attach a host volume in the usual Docker way, to preserve your data on your host machine:

[source,sh]
----
docker run \
  -tip 3000:3000 \
  -v /path/to/host/dir:/var/lib/xtdb \
  ghcr.io/xtdb/xtdb-standalone-ea
----

=== Connecting through HTTP

You can then connect to your XTDB server using cURL, or similar tools.
For example, to check its status:

[source,shell]
----
curl http://localhost:3000/status
----

To run your first query:

[source,shell]
----
sql="SELECT t1.doc.foo[1]
     FROM (VALUES ({'foo':['Hello', 'world!']})) AS t1(doc)"; \
curl --json "{\"query\": {\"sql\": \"${sql}\"}}" localhost:3000/query
----

From here, check out the link:/drivers/http/openapi/index.html[HTTP OpenAPI docs] to see what else is available.

=== Connecting from a client library

If you're running on the JVM, you can use the JVM client library to connect to this node.

[.lang-icons.right]
image:{icon}/clojure.svg[Clojure,link={clojure}#_connecting_through_http]
image:{icon}/java.svg[Clojure,link={java}#_connecting_through_http]
image:{icon}/kotlin.svg[Clojure,link={kotlin}#_connecting_through_http]

For more details, check out the relevant instructions for your language:

== In process (JVM)

If you're running a JVM (17+), you can also use XTDB directly, in-process, using the same API interface as the remote client.
In-process XTDB is particularly useful for testing and interactive development - you can start an in-memory node quickly and with little hassle, which makes it a great tool for unit tests and REPL experimentation.

[.lang-icons.right]
image:{icon}/clojure.svg[Clojure,link={clojure}#_in_process]
image:{icon}/java.svg[Clojure,link={java}#_in_process]
image:{icon}/kotlin.svg[Clojure,link={kotlin}#_in_process]

For more details, check out the relevant instructions for your language:
